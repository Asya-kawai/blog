# 多相性と多相型

**多相性**（Polymorphism）とはどのような型に属しても良いという性質。

多相性を型として表現したものが**多相型**（Polymorphic type）。

## プログラミング言語におけるパラメータ多相とは

多相性の概念をプログラミング言語でもそのまま主張される。

パラメータ多相とは、Parametricityというラムダ項の性質に由来するものではないかと推測。

パラメータ多相の関数は、型変数にどのような値が渡されようとも振る舞いは同じであるという特徴がある。

## 多相型の例

`id : 'a -> 'a`を考える。

### 問題提起

'aにint型を与えるとint（処理系が表現するintのバイト数）として処理される。

doubleの場合はdoubleとして処理される。

つまり、「同一の動作」をするコードなど存在しないのではないか。

パラメータ多相とは、いわば学術的虚構ではないか。

## 従来のパラメータ多相を実現するための値の表現

 多相型の表現をポインタ型と同じ表現として（つまりint32,int64,float型の値は、実際の値へのポインタとして）、
 すべての型を同じビット長（すべての型を64bitで表現するなど）で扱うことで、パラメータ多相を実現している。

ref: OCamlの byterun/caml/mlvalues.h 

### Note

「型変数にあらゆる値が渡されようとも振る舞いは同じ」というのは、上記を踏まえてよく考える必要がある。

## SML#の多相性関数の紹介

```
val id = fn x => x ;
val id = ['a.fn $:TAGty('a) * SIZEty('a) => fn x => x]
```

* TAGty(t)： tがポインタか否か
* SIZEty(t)： tのサイズ

SML#では、上記を用いることで型に応じたコードを生成している。

## Cにおける多相性と多相関数

memcpyは一種の多相的な関数とみなすことができる。

```
void *memcpy(void *dest, const void *src, size_t n);
```
* dest: コピー先のポインタ
* src: コピー元のポインタ
* n: コピー領域の大きさ（バイト）

これをベースに考えると、map（これは多相関数）も作成できる。

## 多相型のランク

`val f = fn(x, y) => y x;`のようにすべての型変数が一度にバインド（インスタンス化）されるものが、ランク0多相。

`val f = fn x => y => y x;`のように型変数が段階的にバインドされるもので、この場合は1つの階層があるのでランク1多相。

## SML#における多相バリアント

SML#では多相バリアントを以下の理由から採用していない。

* datatypeと役割が同じであるため
* 多相レコードがあれば、同じものを表現できるため

## 参考

* [多相性の本質を理解する：「パラメータ多相」？とvoid *多相（SML# とCで始める本格的プログラミング入門 第16回）](https://www.youtube.com/watch?v=oX-yxAELx6E&t=112s)
