# 型理論とは何であるか

# はじめに

[コンパイラ ー原理と構造ー 第１３回 型の解析と型推論（１）型と型システムの考え方，型システムの定義](https://youtu.be/Mqzhn5hVSBE?si=biZBEboxOZiAtmRI) がとても良かったので、じぶんなりにまとめてみた。

## 言語の定義と解析

言語の定義と解析は以下の順序で行われる。

1. 文字列は、任意のアルファベットなどの文字から生成される文字列集合であり
1. 語彙は、名前や区切り記号などの正規言語として表現され
1. 文章は、主語、述語、文などの**文法**によって定義および解析される

ここでの文法とは文脈自由文法であり、これは文脈に依存しない文法である。

文脈自由文法にはBNFが含まれるが、
およそすべての言語は文脈依存の文法を含み、制約を満たさない文法は文とはみなされない。  
すなわち、文脈自由文法は**文法**の近似にすぎないことに留意する。

以降で、文脈自由文法では対応できない点を述べる。

## 文脈自由文法の限界

おおよそすべての言語体系として、以下のような文脈依存が考えられる。

* 名前の定義と参照: 言語内で参照される名前は、参照前に定義されている必要がある
  * `let foo = x;;`が正しい文法であるためには、xが予め定義されていなければいけない
* 名前の利用方法: 名前を利用する関数は、その名前の定義に従って利用する必要がある
  * `let x = (fun x y -> x + y) foo`が正しい文法であるためには、fooはint型の値でなければいけない

これらの制約は文脈依存であるため、文脈自由文法で定義が困難である。

## 文脈依存に対する回答：型推論

文脈自由文法の限界が分かったところで、それにどのように立ち向かうかを説明する。

プログラミング言語では、文章の定義と解析において次の2つのアプローチを採用する場合がある。

1. 文の構造に対して、文脈自由文法を用いる
1. 文脈依存の制御に対して、型理論（型システム）を用いる

型理論とは、文脈依存の制約を含む関係について、数理論理学の枠組みを定義する体系である。

この体系を**型**という。

## 型とはなにか

まず型の直感的理解として「型は値の集合である」というのが良いだろう。

OCamlでは下記のように`let x = 1`を定義するとxはint型で、その値は1であると解釈される。

```
utop # let x = 1;;
val x : int = 1
```

型のもう一つの役割として「データ構造を表現する」がある。  
データ構造には無数の種類が考えられるため、型から型を生成するための**型構成子**を用いる。

OCamlでは下記のように、タプルの型構成子がアスタリスク(*)になっている。  
最終的に変数pは`((int * int) * (int * int)) * ((int * int) * (int * int))`というデータ構造を持つことがわかる。

```
utop # let tuple_a = (1, 2) ;;
val tuple_a : int * int = (1, 2)

utop # let p = (tuple_a, tuple_a) ;;
val p : (int * int) * (int * int) = ((1, 2), (1, 2))

utop # let p = (p, p) ;;
val p : ((int * int) * (int * int)) * ((int * int) * (int * int)) =
  (((1, 2), (1, 2)), ((1, 2), (1, 2)))
```

型の最後の役割として、「関数の振る舞い（関数の値）」がある。  
型は関数がどのようなデータ構造を受け取り、どのようなデータ構造を返すかを定義する。

## 型理論の考え方（重要）

（ここは自分の言葉で書こうにも資料がとてもまとまっており、別表現で表すことが不要）

**型は値（関数を含む）の性質を表す述語**である。  
型理論の目指すところは「値の性質を表す型を、式の述語として用いること」ともいえるが、
式は値ではないから、値の述語のような解釈をそのまま用いることはできない。

なぜなら、`let x = ...`というint型を返す式があったとしても「式であるxそのものがint型である」とは言えないからである。

そこで式の述語の解釈を「**式を解釈、実行し得られるであろう結果の値が満たすべき性質**」とする。

## 式の型における文脈依存性の解釈

式`<exp>`の型を「式を実行し得られるであろう結果の値が満たすべき性質」とすれば、
式`<exp>`の型は「式`<exp>`に含まれる変数の値に依存する」。

たとえば以下のように、式`<exp>`の前に変数x,yが定義されてる場合を考える。

```
utop # let x = 1 ;;
val x : int = 1

utop # let y = 2 ;;
val y : int = 2

utop # let exp = ... ;;
```

式`<exp>`の環境は、文脈`let x = 1`および`let y = 2`によって作られる。  
つまり式`<exp>`が内部でxおよびyを利用していれば、式の値は文脈であるx,yによって作られることを意味する。

## 型判定

次に文脈依存における型判定を説明する。

さきほどの上記の例の`<exp>`が変数xとすると、すなわち環境`{x : 1, y : 2}`の下での実行または評価は、以下のようになる。

```
{x : 1, y : 2} |= x ⇓ 99
```

さきほども説明した内容であるが、xの型がintであると判定するためには、環境の型の記述`{x : 1, y : 2}`が必要である。

---

環境の型の記述を**型環境**といい、メタ変数 **Γ（ガンマ）** で表現する。  
`Γ = {x_1:τ_1,...x_n:τ_n}`のとき、変数`{x_1,...x_n}`を含む式eが型τであると判定できる。  
この判定を以下のように書く。これを**型判定**という。

```
Γ |- e : τ
```

このように型判定を行うシステムが型システムであり、文脈自由文法では表現できない文脈依存の制約を表現できる。

## 型環境の表記ルール

型環境`Γ`を「変数の有限集合から型への関数」と定義する。  
型環境は前述同様に`{x_1:τ_1,...x_n:τ_n}`と表記する。

与えられた型環境`Γ_1,Γ_2`に対して、記法`Γ_1Γ_2`で、`Γ'`（ガンマプライム）を以下のとおり表すことにする。

```
# Γ_1およびΓ_2の定義域を合わせたもの
dom(Γ') = dom(Γ_1) or dom(Γ_2)
           
           Γ_2(x) ... (xがdom(Γ_2)に含まれていれば)
Γ'      = 
           Γ_1(x) ... (xがdom(Γ_2)に含まれていなければ)
```

すなわち記法`Γ_1Γ_2`は「`Γ_2`は`Γ_1`をオーバーライドする」ことに他ならない。

# 参考

* [コンパイラ ー原理と構造ー 第１３回 型の解析と型推論（１）型と型システムの考え方，型システムの定義](https://youtu.be/Mqzhn5hVSBE?si=biZBEboxOZiAtmRI)
* [Asterix in function signature reported by the compiler?](https://discuss.ocaml.org/t/asterix-in-function-signature-reported-by-the-compiler/7141)
