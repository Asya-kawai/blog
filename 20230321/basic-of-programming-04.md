# プログラミングの基礎理論 第4回 自由に生成された集合と再帰的関数、暗黙に型付けられたラムダ計算

帰納的閉包のさらなる理解のために、

* 自由に生成された集合
* 再帰的関数定義

について理解するのが良いので概要のみ紹介する。

## 自由に生成された集合

帰納的閉包 X = Ind(C, F)が以下の条件を満たすとき、「自由に生成された集合である」と言う。

1. 任意の異なる関数f<sup>r(n)</sup>,g<sup>r(m)</sup> &isin; Fに対して、f<sup>r(n)</sup>(X) &cap; g<sup>r(m)</sup>(X) = &empty; である。
  1.1 つまり異なる関数を適用した結果の共通集合はなく、すなわち異なる関数を適用した結果はそれぞれ異なることを意味する
2. 任意の関数f<sup>r(n)</sup> &isin; Fについて、f<sup>r(n)</sup>(X) &cap; C = &empty; である
  2.1 つまり関数を適用した場合、定数Cを生成することはないことを意味する
3. 任意の関数f<sup>r(n)</sup> &isin; Fについて、f<sup>r(n)</sup>|<sub>x<sup>n</sup></sub> は単射関数である
  3.1 fのXへの制限すなわち定義域をXに制限した集合{(a, b) | (a, b) &isin; f, a &isin; X}で表される関数を、f|<sub>x</sub>と表記するのであった
  3.2 <sub>x<sup>n</sup></sub>はn次の直積を表す
  3.3 上記はf自身が同じものを生成することはない、つまり引数が異なれば必ず異なる結果を生成することを意味する

上記は直感的に「Fで生成される要素は既存のものとは異なる新しい要素である」ことを示している。

以降は帰納的閉包を、自由に生成された集合の定義とみなす。
つまり上記3つの条件を満たすこととし、別の言い方をすれば以下の2つだとも言える。

* BNF等の文法規則は、文字列ではなく構文木の集合を定義する規則である
* 証明規則は、正しい論理式やシーケンスのみでなく、その証明過程を含む証明木の集合を定義する規則である

※ みなす、と言われているのでしょうがないが...

## 関数の再帰的定義

Aを任意の集合とする。  
また、X = Ind(C, F)は帰納的閉包であるが、ここでは自由に生成された集合（つまり前述の3つの条件を満たす）とする。

Cの要素をcとし各cに対してAの要素_cが与えられるとする。  
各f<sup>r(n)</sup>に対して関数f<sup>r(n)</sup> &isin; A<sup>n</sup> &rarr; Aが与えられたとき、以下の条件を満たす関数&psi; &isin; X &rarr; Aが唯一存在する。

* 任意の定数cに対して、&psi;(c) = _c
* Xの要素f<sup>r(n)</sup>(x<sub>1</sub>, ... , x<sub>n</sub>)について、&psi;(f<sup>r(n)</sup>(x<sub>1</sub>, ... , x<sub>n</sub>)) = _f<sup>r(n)</sup>(&psi;(x<sub>1</sub>,...,&psi;(x<sub>n</sub>)))

つまり、上記の2つの条件を与えることができれば、関数の再帰的定義が可能と言える。

この関数&psi;を、関数&lambda;c &isin; C.<sub>_c</sub>の _f<sup>r(n)</sup>に関する唯一の**準同型拡張**と呼ぶ。

## 型無しラムダ式

型推論の対象は以下のBNFで定義される型無しラムダ式である。

```
e ::= x | c^b | lambda x.e | e e
```

カッコが不要になるため、省略するのが慣例となっている。  
ただし以下のルールを仮定する。

* 必要に応じてカッコを用いて良い
* &lambda;x.eにおけるeはできる限り大きくとる
  * (&lambda;x<sub>1</sub>.&lambda;x<sub>2</sub>...(&lambda;x<sub>n</sub>.e)...)は&lambda;x<sub>1</sub>.&lambda;x<sub>2</sub>...&lambda;x<sub>n</sub>.e と表記できる
* 関数適用は左結合とする
  * ((e<sub>1</sub> e<sub>2</sub>) ... e<sub>n</sub>)はe<sub>1</sub> e<sub>2</sub> ... e<sub>n</sub>と表記できる

## ラムダ式の意味（おさらい）

* &lambda;x.eは、xを仮引数として値eを計算する関数を表す
* e<sub>1</sub> e<sub>2</sub>は、関数e<sub>1</sub>に対して関数e<sub>2</sub>を適用した結果を表す

この直感的な意味は、ラムダ式の簡約関係 (&lambda;x.e<sub>1</sub>) e<sub>2</sub> &rArr; [e<sub>2</sub>/x]e<sub>1</sub> である。

## 型の集合と型の直感的意味

基底型（これ以上型を持たない）の集合をb,tとする（BaseTypeが由来）。  
また加算無限個の型変数の集合のメタ変数をTVarとする。

型の集合Typeを以下のように定義する。

&tau; ::= t | b | &tau; &rarr; &tau;

上記の意味は、

* t : 集合Typeの変数
* b : intやstring等の与えられた基底型
* &tau;<sub>1</sub> &rarr; &tau;<sub>2</sub> : &tau;<sub>1</sub> から &tau;<sub>2</sub> への関数の型

型表記のおさらい

* 関数型構成子→は右結合とする
  * 例えば、b → b → b のとき、b → (b → b) と解釈する

## 型システムの考え方

型システムとは、以下の関係を含む式の整合性を記述するものと考えることができる。

* 変数の定義と参照関係
* 関数と引数の適用関係

ここで変数が定義される文脈を表現する型環境を&Gamma;する。  
このとき型システムは以下のように、型判定の導出システム（証明システム）として定義できる。

&Gamma; :> e : &tau;

つまり式eは何らかの型集合&tau;にマッピングできる（これを判定する）システムだと言っている。

なお、型環境&Gamma;は変数の有限集合から型への関数であり {x<sub>1</sub> : &tau;<sub>1</sub>, ..., x<sub>n</sub> : &tau;<sub>n</sub>} と記述できる。

## 型判定

例えば、式(f x)（関数fが引数xに適用された形）の変数f及びxは、
この式を囲む文脈（例えば &lambda;f. ... &lambda;x. ... のようなもの）で参照される。

このとき、この式は以下の型判定を持つ。

{ f : &tau;<sub>1</sub> &rarr; &tau;<sub>2</sub>, x : &tau;<sub>2</sub>} :> f x : &tau;<sub>2</sub>

上記の意味は、

* fが型(&tau;<sub>1</sub> &rarr; &tau;<sub>2</sub>)の変数であり、xが型&tau;<sub>1</sub>の変数であると定義された環境の下で、
* 式(f x)は型&tau;<sub>2</sub>を持つ

である。

すなわち、この型判定は上記の意味を主張する**文（シーケント）**である。

## 型推論規則（型付け規則）

構造を持たない式（変数と定数）に対して、以下の2つの規則を導入する。

* (var) &Gamma; {x : &tau;} :> x : &tau;
* (const) &Gamma; :> c<sup>b</sup> : b
  * bはcの基底型を表すのであった

(var),(const)は規則名である。  
これらの規則はすべて導出可能である。

次に部分式を持つ式に対して、以下の2つの規則を導入する。

* (abs) &Gamma; {x : &tau;<sub>1</sub>} :> e : &tau;<sub>2</sub> が導出できれば &Gamma; :> &lambda;x.e : &tau;<sub>1</sub> &rarr; &tau;<sub>2</sub> が導出できる
  * これは{x : &tau;<sub>1</sub>}を仮定できる環境下でeが&tau;<sub>2</sub>の型を持てば、ある環境&Gamma;の下で&lambda;x.eは(&tau;<sub>1</sub> &rarr; &tau;<sub>2</sub>)という関数型を持つ、と言っている
* (app) &Gamma; :>  e<sub>1</sub> : &tau;<sub>1</sub> &rarr; &tau;<sub>2</sub> 及び &Gamma; :>  e<sub>2</sub> : &tau;<sub>1</sub> が導出できれば &Gamma; :> e<sub>1</sub> e<sub>2</sub> : &tau;<sub>2</sub> が導出できる
  * 規則(abs)から意味は容易に想像できるため割愛

ワンポイント： ある式が与えられ「それに対する型判定の導出をせよ」と言われたら、一番下に式を書き導出規則を逆に適用する（つまり下から上の式を導く）形で行おう！

Ref: [型判定導出の例](https://youtu.be/ZP8u0QZ6514?t=2435)

## 暗黙に型付けられたラムダ計算

型なしラムダ計算と型推論規則の集合は**「暗黙に型付けられたラムダ計算」**と呼ぶ型付きの計算系を意味する。  
この計算系を &lambda; と書く。

&lambda; の項は型無しラムダ式eではなく、型導出を持つ型判定である。

なるほど！つまり &lambda; において型が合わないような計算は存在し得ないということ。

型判定 &Gamma; :> e : &tau; （実際には型推論規則でもあるが）に対して型導出（D(&Gamma; :> e : &tau;) &isin; Typing(&Gamma; :> &tau;)）が存在するとき（すなわち導出木が形成できる場合）、 &lambda; |- &Gamma; :> e : &tau; と書く。

つまり型システムの推論対象は &lambda; |- &Gamma; :> e : &tau; で表される &Gamma; :> e : &tau; と言える。

# 参考

* [「型推論」特別講義 第４回 （プログラミング言語の基礎理論シリーズ）](https://youtu.be/ZP8u0QZ6514)
